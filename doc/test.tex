\subsection{根正态分布的多项式}

为了验证数值算法所求根的准确性，我们考虑先生成多项式的精确实根，再根据实根构造出对应的多项式，最后将所求出的实根与精确实根比较。在多项式的生成、输入输出中，应当特别注意控制系数的误差。以下例子说明了微小误差可能带来的影响：

\begin{example}[Wilkinson 多项式]~

	令 $f(x) = (x-1)(x-2)\dots(x-20)$，则有 $x^{19}$ 的系数为 $-210$。假设这一位在系数计算的时候，有误差 $2^{-50}$，即系数 $x^{19}$ 的系数变为了 $-210 - 2^{-50}$，则对应多项式的根会有将近 $10^{-6}$ 的绝对误差。

	以下根由 matlab 计算，并使用 WolframAlpha 的解方程功能进行验算，保留 $30$ 位有效数字。

	$$
	\begin{aligned}
		x_1&=1.0 \\
		x_2&=2.00000000000000000000000007273 \\
		x_3&=2.99999999999999999999854887259 \\
		x_4&=4.00000000000000000194477430517 \\
		x_5&=4.99999999999999946021669717504 \\
		x_6&=6.00000000000005173499077404847 \\
		x_7&=6.99999999999774186363726442871 \\
		x_8&=8.00000000005302033521539523965 \\
		x_9&=8.9999999992545274542491495908 \\
		x_{10}&=10.0000000067448789047907040528 \\
	\end{aligned}
	$$
	$$
	\begin{aligned}
		x_{11}&=10.9999999587489374253459884266 \\
		x_{12}&=12.000000176306266307312631226 \\
		x_{13}&=12.9999994621561736626061961 \\
		x_{14}&=14.0000011839146762070409774592 \\
		x_{15}&=14.9999981178930569438048981748 \\
		x_{16}&=16.0000021383017452406264960673 \\
		x_{17}&=16.9999983085498826309361187107 \\
		x_{18}&=18.0000008842579304437204465685 \\
		x_{19}&=18.9999997255408001641186061227 \\
		x_{20}&=20.0000000382803121076227530584 \\
	\end{aligned}
	$$

	\contribution{潘佳奇}
\end{example}

经过考虑，在生成测试集时，使用正态分布随机根的数据。

\begin{algorithm}[生成测试多项式]~

	对于多项式的度数，随机一个在 $[1,20]$ 上的整数，记为 $d$。以 $80\%$ 的概率生成带有重根的多项式，如果没有重根，令 $d'=d$，否则使用标准正态分布随机一个实数 $p$，并令 $d'=\max(1,d-\lceil \min(|p|,1)d\rceil)$。对于前 $d'$ 个根，使用标准正态分布获取一个值，对于后 $d-d'$ 个根，分别在前 $d$ 个根中等概率随机选取一个根作为自身的值。
	获取根后，将根排序，并使用多项式乘法计算出这些根对应的多项式。在输出的数据中，所有浮点数保留 $64$ 位有效数字。
	
	时间复杂度：$O(d^2)$。
	
	\contribution{潘佳奇}
	
\end{algorithm}

\begin{conjecture}[]~
	
	对于能够保证生成的多项式精度情况较好，使算法在读入的时候带来的误差对根影响较小。
	
	\contribution{潘佳奇}
\end{conjecture}

其中根据正态分布获取随机数的算法如下：

\begin{algorithm}[Marsaglia 极坐标法]~
	
	设正态分布的均值为 $\mu$ ，方差为 $\sigma ^ 2$ 。
	
	\textbf{步骤1.} 不断地随机二元组 $(s, v)$（其中 $u, v$ 均服从 $(-1, 1)$ 上的均匀分布），直到 $0 < u^2 + v^2 < 1$ 。
	
	\textbf{步骤2.} 令 $s = u^2 + v^2, t = \sqrt{\frac{-2\ln s}{s}}$，返回两个数 $\mu + \sigma t \mu, \mu + \sigma tv$ 作为随机数结果。
	
	时间复杂度：$O(1)$。
	
	\contribution{潘佳奇}
\end{algorithm}

\subsection{形态更全面的多项式}

	由于在后续算法优化中使用了 gmp 库，我们用 gmp 库重写了测试方法，包含在testlib.cpp 和testlib.h中。目前的测试方法支持三种功能：随机生成指定数量的根整数、根为实数的多项式，以及复用上一次生成过的多项式。生成的多项式数量nTests和容差要求e需在代码中修改，而生成模式由cin输入。 
	
	\begin{algorithm}[测试方法（简略）]~
		
		输入：一个整数mode，代表测试模式。$0$ 为复用，$1$为整根多项式，$2$为实根多项式。
		
		\textbf{步骤1.} 若 $\textrm{mode} = 0$ ，则从poly.rawin中读取上一次生成的精确原始多项式，以 gmp 高精度有理数形式存储并输出。否则，进入步骤2。
		
		\textbf{步骤2.} 随机生成一个 $[2, 19]$ 的整数 $n$ ，代表多项式的次数。随后按照mode要求，在 $[-10, 10]$ 范围内随机生成 $n$ 个实根，或是在 $[-100, 100]$ 范围内随机生成 $n$ 个不等整根，将其存储为 gmp 高精度有理数格式。
		
		\textbf{步骤3.} 把生成的根展开为多项式，获得 gmp 高精度有理数格式的多项式系数。将 unsigned long long 格式的根和系数输出至poly.raw中。
		
		\textbf{步骤4.} 将多项式分别传入三种不同实现的 gb\_solve() 方法，获得三组不同结果。将三组结果之间分别与生成的标准根比较，输出超出容差的根组数；再将三组结果彼此互相比较，输出超出容差的根组数。
		
		\textbf{步骤5.} 如果希望下一次测试复用某一组数据，则在poly.raw中找到待用数据，复制进poly.rawin中。
		
		\textbf{步骤6.} 若当前测试多项式数量已达到nTests，则退出；否则跳转至步骤2。
		
		\textbf{算法结束。}
		
		\contribution{叶隽希}
		
	\end{algorithm}


\subsection{测试与改进}

	\subsubsection*{读入误差}

	初步测试之后，注意到的首要问题是三种不同算法所求出实根彼此的误差均在所给定容差范围内，但和标准根对比，其均有相同数量的根超出容差。
	
	\begin{example}[读入误差1]~
		
		在求解如下多项式方程时
		$$
		\begin{aligned}
		& -601.8724797782923587874392978847026824951171875 \\ 
		& - 372.28844745806571836510556749999523162841796875x \\
		& + 202.587299451655582060993765480816364288330078125x^2 \\
		& + 52.03053344897322318729493417777121067047119140625x^3 \\
		& - 16.696989593724016032183499191887676715850830078125x^4 \\
		& + x^5
		\end{aligned}
		$$
		
		测试程序提示标准根与算法2, 4 ,5生成的实根各有两个误差超过容差，而算法2, 4, 5生成的实根彼此没有误差超过容差。具体而言，标准根应当是
		$$
		\begin{aligned}
		& -2.53715102852721452464379581215325742959976196289062500 \\
		& -1.18124041966657156166320419288240373134613037109375000 \\
		& 2.51042032439969942103630273777525871992111206054687500 \\
		& 8.56523949619504598729236022336408495903015136718750000 \\
		& 9.33972122132305848651867563603445887565612792968750000
		\end{aligned}
		$$
		
		算法2, 4, 5给出的实根是
		$$
		\begin{aligned}
		& -2.53715102852721496873300566221587359905242919921875000 \\
		& -1.18124041966657178370780911791371181607246398925781250 \\
		& 2.51042032439969942103630273777525871992111206054687500 \\
		& 8.56523949619507440900179062737151980400085449218750000 \\
		& 9.33972122132303006480924523202702403068542480468750000
		\end{aligned}
		$$
		\contribution{吕敬一}
		
	\end{example}

	对 Sturm-Newton 算法调整了迭代终止条件，强制增加了迭代次数，发现输出结果和标准答案的误差完全没有改变，基本说明gb\_solve()的求解过程并未导致过大的误差。 
	
	由于数据生成中采用了无误差的高精度数，初步判断该误差来源是将生成数据输入gb\_solve()时，由于gb\_solve()要求输入多项式系数为double类型，发生了丢失精度的类型转换。根据先前Wilkinson多项式的例子，在次数较高时，多项式系数的微小扰动也会带来实根明显的误差。考虑到double类型丢失精度不可避免，故认为这并不属于算法涉及的明显缺陷。
	
	\begin{example}[读入误差2]~
		
		在mode = 1下生成了具有如下30个实根的多项式：
		$$
		\begin{aligned}
		& -97,-88,-86,-84,-83,-82,-77,-59,-55,-42,-40,-39,-34,-28,-22,-14,-11, \\
		& 3,24,28,47,52,59,64,66,73,80,88,89,91
		\end{aligned}
		$$
		
		注意到实根中有10的倍数（40和80），展开后的多项式常数项应当为10的倍数。然而输入数据显示double类型的多项式系数中常数项为
		$$
		-113260460306063369995491810216948300274714967801856
		$$ 
		
		显然发生了矛盾。
		\contribution{吕敬一}
	
	\end{example}

	这个例子表明double类型存储多项式系数对于过高的次数或者过大的系数也会产生显著的读入误差，且很难避免。

    % 这里好像逻辑跟先前的文档设计不太一样
    % 应该放到自己算法的下面？
    
    \subsubsection*{舍入误差}

    当我们将测试数据调整为度数不超过 10，精确根为绝对值不超过 100 的整数，容差设置为 $10^{-15}$ 时，发现算法的输出出现了问题。

    \begin{example}[舍入误差]~

        在求解如下多项式方程时：

        \[ 108 -21x +x^2 = 0 \]
        
        算法 \ref{bisection-isolation} 给出了 \verb|double| 类型下的结果：

        \[ x_1 = 8.9999999999999982236431605997495353221893310546875, x_2 = 12\]
        
        误差超过了给定的 $10^{-15}$ 。
       	\contribution{吕敬一}
        
    \end{example}

	由于之前测试之中 $10^{-15}$ 的容差在长期测试下并未出现问题，这一组简单数据却超出了容差，这引起了我们的注意。
	
	起初怀疑是算法精度不足，但在同时增加二分层数、牛顿迭代次数、粗略约分的精度后，算法运行时间虽已数十倍地增长，但给出的结果并未改变。
	
	在经历了更多的调试后我们偶然发现，算法给出的 $x_1$ 与实际的根 $9$ 在IEEE 754标准的 \verb|double| 意义下实际是相邻的。
	
	\begin{myverbatim}
		\verbatiminput{reinterpret.cpp}
	\end{myverbatim}
	
	这一段代码给出的输出为
	
	\begin{verbatim}
		9.00000000000000000000000000000000000000000000000000
		0100000000100010000000000000000000000000000000000000000000000000
		8.99999999999999822364316059974953532218933105468750
		0100000000100001111111111111111111111111111111111111111111111111
	\end{verbatim}
	
	随即我们意识到，问题产生于我们使用的高精度库 gmp，由于我们在计算过程中采用的是高精度有理数，而返回时需要转化成 \verb|double| 类型，故而我们使用了 gmp 库提供的 \verb|get_d()| 方法。然而，查阅资料后发现，这一方法返回时并未四舍五入，而是采用了向零取整。而由于算法原理的原因，我们计算出的当前实根近似值虽然非常接近真实值 $9$，但却始终不到 $9$，向零取整后便变为了现在给出的 $x_1$。采用了自己实现的四舍五入方法后，这一问题便改善了（但没有完全解决）。